---
title: "Cellosaurus"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Cellosaurus}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction
Cellosaurus is a comprehensive knowledge resource dedicated to cell lines,
providing a wealth of information about various types of cells used in
biomedical research. It serves as a centralized repository that offers
detailed data on cell lines, including their origins, characteristics,
authentication methods, references, and more. Please view the Cellosaurus
website at https://web.expasy.org/cellosaurus/ for more information and
a detailed description can be found at https://www.cellosaurus.org/description.html.

The `AnnotationGx` package provides a wrapper around the Cellosaurus API to 
map cell line identifiers to the Cellosaurus database fields. 

### Setup

```{r setup}
library(AnnotationGx)
library(data.table)

```


### Mapping from Cell Line name to Accession id
The main function that is provided by the package is `mapCell2Accession`. This function
takes in a vector of cell line identifiers and returns a `data.table`. 

```
Usage and default values:
     mapCell2Accession(
       ids,
       numResults = 1000,
       from = "id",
       to = c("id", "ac"),
       prioritizeParent = FALSE,
       orderby = "ac",
       query_only = FALSE,
       raw = FALSE,
       BPPARAM = BiocParallel::SerialParam(),
       ...
     )
```

Let's see how we can use this function to map the "HeLa" and "A549" cell line names
to the Cellosaurus database. 
By default, the function will try to map using the common identifier (`from ="id"`) name and 
will return the standard identifier `id` and the Cellosaurus accession ID `ac`. The 
function also returns two additional columns `query` and `query:<from>` which
can be used to identify the original query and the original identifier type if needed. 
``` {r map heLa each}
mapCell2Accession("hela", numResults=1)
```

### misspelled or non-standard cell line names

Sometimes the cell line name might be misspelled or might not be the standard name. 
This is the case if we query for "A549" in the same way. 
``` {r map one name each}
# our query:
mapCell2Accession("A549", from = "id", numResults=1)

# if we use the actual standard name:
mapCell2Accession("A-549", from = "id", numResults=1)

# trying to get the standard name with more results
mapCell2Accession("A549", from = "id", numResults=10)
```

The main identifier for the A549 cell line is "A-549" with accesion id of "CVCL_0023" 
which does not appear in even the first 10 results (it would be the 40th result 
if we adjust the `numResults` parameter) and while we could manually adjust every query 
to match the standard name, this is not feasible for hundreds of cell lines. 

There are a few ways to deal with this issue. 
The first method is based on the reasoning that many of the cell lines are derived from a parent cell line.
To deal with this issue, we can use the `prioritizeParent` argument. 
This argument will use the parent cell line of each returned result and prioritize the
results based on the accession id of the parent cell line. 

``` {r map A549 each}
mapCell2Accession("A549", from = "id", numResults=1, prioritizeParent=TRUE)
```

Another example using the BT474 cell line. 

``` {r map BT474 each}
mapCell2Accession("BT474", numResults=1, prioritizeParent=FALSE)


mapCell2Accession("BT474", numResults=1, prioritizeParent=TRUE)
```





### Example pipeline to annotate a dataset
#TODO::incomplete

We will be working with some data from the GDSC and Cell Model Passports datasets 
for this vignette. The GDSC dataset contains information about the cell lines 
in the Genomics of Drug Sensitivity in Cancer (GDSC) project. The Cell Model
Passports dataset contains information about all the models in the the database.


The GDSC sampleMetadata contains two columns, `GDSC.Sample_Name` and `GDSC.COSMIC_ID`.
``` {r setup data}
data(gdsc_sampleMetadata)
data(cell_model_passports_models)
```

```{r view data}
# head(gdsc_sampleMetadata)

```


```{r map one name}
# By default, the function will try to map using the common identifier name to the Cellosaurus accession number
# AnnotationGx::mapCell2Accession(gdsc_sampleMetadata[["GDSC.Sample_Name"]])

```


```{r view data2}
# head(cell_model_passports_models)

```


```{r map one name to fields}
# fields <- c("id", "ac", "sy", "sx", "ag", "derived-from-site")

# By passing the fields argument, the function will return the information for the fields specified
# AnnotationGx::mapCell2Accession(cell_model_passports_models[["CMP.model_name"]], to=fields) |> head()

```


```{r map using names}
# field_map <- list(
#     "id" = "id",
#     "ac" = "accession",
#     "sy" = "synonyms",
#     "misspelling" = "misspellings",
#     "di" = "diseases",
#     "ca" = "category",
#     "sx" = "sexOfCell",
#     "ag" = "ageAtSampling",
#     "derived-from-site" = "samplingSite"
# )
# fields <- names(field_map)
# gdsc_sampleMetadata[, paste0("cellosaurus.", fields ) := {
#     mapped <- AnnotationGx::mapCell2Accession(
#         as.character(GDSC.COSMIC_ID),
#         from = "dr",
#         to = fields
#     )
#     return(mapped[, 1:length(fields)])
#     }
# ]



# # rename using map
# for (i in names(field_map)) {
#     data.table::setnames(gdsc_sampleMetadata,
#     paste0("cellosaurus.", i), paste0("cellosaurus.", field_map[[i]]), skip_absent = TRUE)
# }

# str(gdsc_sampleMetadata[1])
```
